通过位运算生成掩码，再通过按位与的结果判断是否有交集

```go
//生成掩码
func CreateMask(setBit ...int) (int, error) {
	var result int
	for _, v := range setBit {
		if v <= 0 {
			return 0, errors.New(fmt.Sprintf("not valid number: %d", v))
		}
		result |= 1 << (v - 1)
	}
	return result, nil
}
```

可以根据以下例子理解：result |= 1 << (v - 1)

**例 1**： mask := 0       

​            mask |= 1 << 3

​        根据 mask |= 1 << 3这个表达式，首先将数字1左移3位（1 << 3），然后将结果与`mask`进行按位或操作，并将最终结果赋值给`mask`变量。

具体计算过程如下：

1.   1 << 3：将数字1左移3位，得到二进制表示为 `00001000`，对应十进制为8。
2.   mask |= 8将 mask 与 8 进行按位或操作，相当于 mask = mask | 8
   - 如果 `mask` 的初始值为0，按位或操作后的结果仍为8。
   - 如果 `mask` 的初始值为其他值，按位或操作将会将第4位（从右向左数，从0开始）设置为1，其余位保持不变。

因此，`mask` 的最终值为8。

总结：`mask |= 1 << 3` 运算后，`mask` 的值为8

**例 2**： mask := 1 

​            mask |= 1 << 2 

根据 mask |= 1 << 2 这个表达式，首先将数字1左移2位（1 << 2），然后将结果与`mask`进行按位或操作，并将最终结果赋值给`mask`变量。

具体计算过程如下：

1.   1 << 2：将数字1左移2位，得到二进制表示为 `00000100`，对应十进制为4。
2.    mask |= 4：将 mask与 4 进行按位或操作，相当于 mask = mask | 4
   - 如果 `mask` 的初始值为1，按位或操作后的结果仍为5。
   - 如果 `mask` 的初始值为其他值，按位或操作将会将第3位（从右向左数，从0开始）设置为1，其余位保持不变。

因此，`mask` 的最终值为5。

总结：`mask |= 1 << 2` 运算后，`mask` 的值为5



```go
//判断两个掩码是否相交
func CheckMask(maskA int, maskB int) bool {
	return maskA&maskB != 0
}
```

函数逻辑解释：

1. 函数使用按位与运算符（`&`）对位掩码`maskA`和`maskB`进行按位与操作。
2. 如果按位与的结果不等于0，则表示存在共同的位，即`maskA`和`maskB`有交集。
3. 如果按位与的结果等于0，则表示不存在共同的位，即`maskA`和`maskB`没有交集

**例如**：假设`maskA`的值为10（二进制表示为1010），`maskB`的值为6（二进制表示为0110）。这两个位掩码的二进制表示分别为：

```go
maskA: 1010
maskB: 0110
```

通过执行`maskA & maskB`按位与操作，得到的结果为2（二进制表示为0010）。由于结果不等于0，所以存在共同的位，即`maskA`和`maskB`有交集。因此，函数将返回`true`